---
layout: post
title: "[TIL] 2025-02-26 / Java 강의 2주차"
date: 2025-02-26 20:20:00 +0900
categories: 
  - til
  - main-camp
---

* toc
{:toc}

## 📖 Today I Learned
### Java 강의 2주차

<!-- <h4> 📃 </h4> -->

---

#### - 클래스(class)
- 객체를 생성하기 위한 설계도 또는 틀
- 클래스를 사용하면 코드의 재사용성을 높이고, 유지보수를 쉽게 할 수 있음

#### - 객체(object)
- 클래스에 의해 생성된 실체
- 클래스에서 정의된 속성과 메서드를 가짐
- `new` 키워드를 사용하여 생성

#### - 인스턴스화(instantiate)
- 클래스를 기반으로 객체를 생성하는 과정
- 클래스를 설계도 삼아 실제 메모리에 할당된 객체를 만드는 것

#### - 속성(property, field)
- 객체의 데이터를 저장하는 변수
- 클래스 내부에서 선언되며, 각 객체마다 다른 값을 가질 수 있음

#### - 생성자(constructor)
- 객체가 생성될 때 자동으로 후출되는 특별한 메서드
- 객체의 초기 값을 설정하는 역할
- 생성자의 이름은 클래스 이름과 동일해야 함

#### - 기능(method)
- 객체의 동작을 정의하는 함수
- 객체의 데이터를 변경하거나 특정 동작을 수행할 때 사용

#### - Method Area
- 메서드 영역, 클래스 영역
- 정적 데이터 및 클래스 정보가 저장되는 영역
- 클래스 정보, 메서드 코드, static 변수 등이 저장됨
- JVM이 시작될 떄 생성되고, 프로그램이 종료될 떄 해제됨
- 모든 스레드가 공유하는 영역

#### - Stack Area
- 각각의 스레드마다 생성되는 영역으로, 메서드 호출 시 할당되는 공간
- 메서드가 호출될 때 지역 변수, 매개변수, 리턴 값, 연산 중간 값 등이 저장
- 메서드가 종료되면 해당 스택 프레임이 제거됨
- 각 스레드마다 개별적인 Stack을 가짐

#### - Heap Area
- 실제 객체가 저장되는 공간
- `new` 키워드로 생성된 객체와 배열이 저장됨
- `Garbage Collector(GC)`에 의해 메모리가 관리 됨
- 모든 스레드에서 공유하는 영역
- 객체는 Heap에 저장되지만, 참조 변수는 Stack에 저장됨

#### - 래퍼클래스
- 기본형 변수를 객체로 감싸는 클래스
- 기본형 타입을 객체로 다룰 수 있도록 제공

| 기본형 타입 | 래퍼 클래스 |
| :---------: | :---------: |
|   `byte`    |   `Byte`    |
|   `short`   |   `Short`   |
|    `int`    |  `Integer`  |
|   `long`    |   `Long`    |
|   `float`   |   `Float`   |
|  `double`   |  `Double`   |
|   `char`    | `Character` |
|  `boolean`  |  `Boolean`  |


#### - 기본형 변수
- 가장 기본적인 데이터 타입으로, 직접 값을 저장하는 변수

| 기본형 타입 |  크기  |  기본값  |          예제          |
| :---------: | :----: | :------: | :--------------------: |
|   `byte`    | 1 byte |    0     |     `byte b = 10;`     |
|   `short`   | 2 byte |    0     |    `short s = 100;`    |
|    `int`    | 4 byte |    0     |   `int num = 1000;`    |
|   `long`    | 8 byte |    0L    |   `long l = 10000L;`   |
|   `float`   | 4 byte |   0.0f   |   `float f = 10.5f;`   |
|  `double`   | 8 byte |   0.0    |   `double d = 20.5;`   |
|   `char`    | 2 byte | '\u0000' |    `char c = 'A';`     |
|  `boolean`  | 1 byte |  false   | `boolean flag = true;` |


#### - 참조형 변수
- 실제 값을 저장하는 것이 아니라, 객체의 주소를 저장

#### - 오토박싱 & 언박싱
- 오토박싱 : 기본형 -> 래퍼 클래스 자동 변환
- 언박싱 : 래퍼 클래스 -> 기본형 자동 변환

#### - static
- `static`변수는 클래스에 속한 변수로, 모든 객체가 공유
- 특징
  - `static`변수는 클래스 로딩 시 메모리에 할당되고, 모든 객체가 이 변수의 값을 공유
  - 객체마다 다른 값을 저장하는 일반 변수와 달리, `static`변수는 클래스에 한번만 할당되고, 모든 객체가 동일한 값을 참조
- `static`메서드는 객체를 생성하지 않고도 호출 가능한 클래스 메서드
- `static`메서드에서 인스턴스 변수나 인스턴스 메서드를 사용할 수 없고, 오직 `static`변수와 `static`메서드만 접근 가능
- 특징
  - 객체를 생성하지 않고도 클래스 이름으로 직접 호출 가능
  - `static`메서드는 객체 상태를 변경할 수 없고 오직 클래스 변수만을 다룰 수 있음

#### - 인스턴스 멤버
- 인스턴스 멤버는 각 객체의 고유한 변수나 메서드로 객체가 생성될 때 메모리에 할당
- 각 객체마다 별도로 존재하며, 객체가 생성된 후에만 접근 가능
- 특징
  - 객체마다 별도 저장
  - `this`키워드를 통해 객체 자신의 멤버에 접근 가능
  - 인스턴스를 생성해야지만 접근 가능

#### - 클래스 멤버
- 클래스에 속한 변수나 메서드로 클래스 수준에서 공유
- `static`키워드를 사용하여 정의
- 클래스에 속한 모든 객체가 공유하므로 객체를 생성하지 않고도 클래스명으로 접근 가능
- 특징
  - 모든 객체가 공유하는 변수나 메서드
  - `static`키워드를 사용하여 정의
  - 객체를 생성하지 않고 클래스명으로 직접 접근 가능

#### - final
- 변수, 메서드, 클래스에 사용되어 수정 불가능 하게 만듬
- 특징
  - 변수에 사용되면 해당 변수는 값을 한 번만 할당할 수 있으며 이후 변경 불가
  - 메서드에 사용되면 해당 메서드는 오버라이드 할 수 없음
  - 클래스에 사용되면 해당 클래스는 상속할 수 없음

#### - 상수
- 변경되지 않는 값을 저장하는 변수
- `final`변수를 사용하여 선언
- 대문자로 선언하며, 여러 단어가 있을 경우 `_`를 사용하여 구분

#### - 불변객체
- 생성된 이후에 그 상태가 변경되지 않는 객체
- 상태 변경이 불가능 하므로 동기화와 관련된 문제를 피할 수 있어 멀티스레딩 환경에 유리
- 특징
  - 생성자에서 모든 값을 설정하고 이후에는 값을 변경할 수 없도록 설계
  - 객체의 멤버 변수는 모두 `final`로 선언하고 값을 변경하는 `setter` 메서드를 제공하지 않음
  - 불변 클래스는 상속할 수 없도록 `final`클래스로 설계하는 경우가 많음

#### - 인터페이스
- 추상 메서드만을 포함할 수 있는 규격 또는 계약을 정의한 참조 타입
- 클래스가 반드시 구현해야 하는 메서드의 시그니처만 정의
- 다중 상속을 허용
- 특징
  - 추상 메서드만을 선언 할수 있음
  - 인터페이스는 클래스가 반드시 구현해야 할 메서드의 서명을 정의
  - `implements`키워드를 사용하여 클래스에서 인터페이스를 구현
  - 다중 상속이 가능하므로 하나의 클래스가 여러 인터페이스를 구현 가능
  - 상수만을 가질 수 있음

#### - 구현체
- 인터페이스에서 정의한 메서드를 실제로 구현하는 클래스
- 인터페이스에서 정의된 추상 메서드를 반드시 구체화하여 사용해야 함
- 특징
  - 인터페이스의 메서드 구현을 제공하는 구체적인 클래스
  - `implements` 키워드를 사용하여 인터페이스를 구현
  - 인터페이스에서 선언된 모든 추상 메서드를 구현해야 함

#### - 캡슐화
- 객체의 상태와 동작을 하나의 단위로 묶어 외부에서 직접 접근하지 못하게 하고 이를 제어하는 방식
- 객체 내부 상태를 외부에서 숨기고 필요한 메서드를 통해서만 데이터를 조작할 수 있게 함
- 특징
  - 정보 은닉과 관련 있음
  - 객체의 변수를 `private`로 선언하여 외부에서 직접 접근할 수 없고 `getter`, `setter` 메서드를 통해 데이터를 처리
  - 외부에서 객체의 상태를 변경할 떄 검증 로직을 추가하여 잘못된 값이 들어가지 않도록 할 수 있음

#### - 정보은닉
- 객체의 내부 구현을 외부로부터 숨기는 기법
- 객체의 내부 상태가 잘못 변경되는 것을 방지, 객체를 사용하는 코드에서 불필요한 내부 구현에 의존하지 않도록 함
- 특징
  - `private` 접근 제어자를 사용하여 클래스의 필드나 메서드를 숨기고 외부에서 그 값이나 메서드를 수정하지 못하게 함
  - 외부에서는 `public` 메서드를 통해서만 객체의 상태에 접근하거나 수정 가능

#### - 접근제어자
- `private` : 클래스 내에서만 접근 가능
- `default` : 같은 패키지 내에서 접근 가능
- `protected` : 같은 패키지 내에서, 또는 자식 클래스에서 접근 가능
- `public` : 어디서든 접근 가능

#### - 상속
- 부모 클래스의 속성과 메서드를 자식 클래스가 물려받는 기능
- 코드 재사용성을 높이고 공통된 기능을 부모 클래스에 정의하여 여러 자식 클래스에 공유 가능
- 특징
  - 자식 클래스는 부모 클래스의 필드와 메서드를 상속 받음
  - 자식 클래스는 부모 클래스의 생성자는 상속받지 않지만 부모 클래스의 생성자는 `super`을 사용하여 호출 가능
  - 자식 클래스는 부모 클래스의 메서드를 오버라이딩하여 새로운 동작을 정의 가능

#### - super
- 부모 클래스의 필드, 메서드, 생성자를 자식 클래스에서 참조할 수 있게 해주는 키워드

#### - 오버라이딩
- 자식 클래스에서 부모 클래스의 메서드를 재정의하여 새로운 동작을 정의하는 것
- 부모 클캐스의 기능을 확장하거나 변경 가능
- 특징
  - 메서드 시그니처가 부모 클래스와 동일해야 함
  - 자식 클래스에서 부모 클래스의 메서드를 재정의할 때 `@Override` 애너테이션을 사용하여 명시적으로 오버라이드를 표시
  - 오버라이딩된 메서드는 부모 클래스에서 정의된 메서드를 덮어 씀

#### - 추상 클래스
- 구현되지 않는 메서드를 포함할 수 있는 클래스
- 객체를 직접 생성할 수 없고, 자식 클래스에서 구현해야 함
- 공통적인 메서드와 속성을 정의하고 세부 구현은 자식 클래스에서 제공하는 역할
- 특징
  - `abstract` 키워드를 사용하여 추상 클래스를 정의
  - 추상 클래스는 추상 메서드와 일반 메서드 모두 가질 수 있음
  - 추상 메서드는 메서드의 시그니처만 정의하고 구현은 자식 클래스에서 함
  - 추상 클래스는 객체를 생성할 수 없고 반드시 자식 클래스에서 상속 받아야 함

#### - 추상화
- 불필요한 세부 구현을 숨기고 필요한 기능만을 노출하는 개념
- 복잡한 시스템을 단순화하는 데 유용하며 자바에서는 추상 클래스와 인터페이스를 사용하여 구현
- 특징
  - 추상 클래스나 인터페이스에서 정의된 메서드는 구현되지 않은 채 선언만 되어 있고 이를 자식 클래스에서 구현해야 함
  - 구체적인 구현을 숨기고 공통적인 부분만 정의함

#### - 다형성
- 하나의 객체가 여러 가지 형태를 가질 수 있는 설징
- 메서드 오버로딩과 메서드 오버라이딩을 통해 구현되며 하나의 타입으로 여러 객체를 다룰수 있음
- 특징
  - 컴파일 타임 다형성 : 같은 이름의 메서드가 매개변수의 개수나 타입에 따라 다르게 동작
  - 런타임 다형성 : 부모 클래스의 메서드를 자식 클래스에서 재정의하여 객체의 실제 타입에 맞게 동작

#### - 업 캐스팅
- 자식 클래스의 객체를 부모 클래스 타입으로 변환 하는 것
- 자식 클래스는 부모 클래스의 속성과 메서드를 모두 상속받아 부모 클래스 타입으로 자식 클래스 객체를 저장할 수 없음
- 특징
  - 자동으로 이루어짐
  - 부모 클래스 타입으로 저장되여 자식 클래스의 고유한 메서드나 필드는 사용할 수 없음
  - 다형성을 활용 가능

#### - 다운 캐스팅
- 부모 클래스 타입의 객체를 자식 클래스 타입으로 변환
- 명시적인 캐스팅이 필요하며 올바른 타입으로 변환해야한 실행 중 오류가 발생하지 않음
- 특징
  - 실행 시간에 캐스팅이 이루어짐
  - 잘못된 타입으로 캐스팅하면 예외가 발생함
  - 객체가 실제로 자식 클래스 타입일 때만 가능한 안전한 캐스팅을 해야 함

<!-- --- -->

<!-- <h2> 💬 </h2> -->

<!-- <h4>  </h4> -->
