---
layout: post
title: "[TIL] 2025-04-10 / JPA 성능 최적화"
date: 2025-04-10 20:20:00 +0900
categories: 
  - til
  - main-camp
---

* toc
{:toc}

## 📖 Today I Learned
### 

<!-- <h4> 📃 </h4> -->

---

#### - Entity가 아닌 DTO 반환 및 사용자 입력 DTO로 받기
- API에서는 Entity를 직접 반환하지 말고 DTO를 사용해야 함
- 사용자 입력도 Entity에 직접 바인딩하지 않고 DTO를 통해 받음
- 이유
  - Entity를 외부에 노출할 경우 : JPA의 영속성 컨텍스트와 연관된 내부 로직이 노출되어 보안 및 유지보수 측면에서 문제 발생
  - API 스펙이 Entity에 종속 : Entity 변경 시 API 전체에 영향을 주는 등 결합도가 높아짐
  - 직렬화 이슈 : Lazy 로딩된 필드가 프록시 객체로 반환되며 Jackson에서 직렬화 실패 가능 성 존재
  - 데이터 검증 어려움 : 입력 값에 대한 검증이 Entity에서 어렵고 책임이 분산됨
- 장점
  - 계층 간 역할 구분
  - 필요한 데이터만 클라이언트에 제공 가능
  - 입력 데이터 검증 및 보안에 유리

#### - Lazy와 Eager
- JPA에서 연관된 엔티티를 로딩하는 전략은 크게 두 가지가 있음
  - 지연 로딩 : 실제로 해당 연관 객체가 호출될 때 쿼리를 실행
  - 즉시 로딩 : 연관 객체를 함께 즉시 로딩함
- Lazy (지연 로딩)
  - 연관된 객체를 사용할 때까지 로딩을 미룸
  - 초기 쿼리 성능 최적화 가능
  - N + 1 문제 발생 가능성 있음
- Eager(즉시 로딩)
  - 연관된 객체를 무조건 함께 로딩
  - 예기치 못한 쿼리 실행
  - 성능 저하 및 복잡한 객체 그래프 구성 시 부적합

#### - 다대일 연관관계 성능 최적화
- 대부분 연관 관계는 다대일 구조
- 기본 Fetch 전략으로 `@ManyToOne`, `@OneToOne`은 `EAGER`로 설정됨
- LAZY로 변경하고 필요 시 fetch join 사용

#### - N + 1 문제 해결방법
1. Fetch Join
- Fetch Join은 연관된 엔티티를 SQL의 JOIN을 사용하여 한 번의 쿼리로 함꼐 조회하는 방법
- JPQL에서만 사용 가능하며 SQL에서의 JOIN과 유사하지만 의미상 차이 있음
- `JOIN FETCH` 키워드를 사용

<!-- --- -->

<!-- <h2> 💬 </h2> -->

<!-- <h4>  </h4> -->
