---
layout: post
title: "[TIL] 2025-04-10 / JPA 성능 최적화"
date: 2025-04-10 20:20:00 +0900
categories: 
  - til
  - main-camp
---

* toc
{:toc}

## 📖 Today I Learned
### 

<!-- <h4> 📃 </h4> -->

---

#### - Entity가 아닌 DTO 반환 및 사용자 입력 DTO로 받기
- API에서는 Entity를 직접 반환하지 말고 DTO를 사용해야 함
- 사용자 입력도 Entity에 직접 바인딩하지 않고 DTO를 통해 받음
- 이유
  - Entity를 외부에 노출할 경우 : JPA의 영속성 컨텍스트와 연관된 내부 로직이 노출되어 보안 및 유지보수 측면에서 문제 발생
  - API 스펙이 Entity에 종속 : Entity 변경 시 API 전체에 영향을 주는 등 결합도가 높아짐
  - 직렬화 이슈 : Lazy 로딩된 필드가 프록시 객체로 반환되며 Jackson에서 직렬화 실패 가능 성 존재
  - 데이터 검증 어려움 : 입력 값에 대한 검증이 Entity에서 어렵고 책임이 분산됨
- 장점
  - 계층 간 역할 구분
  - 필요한 데이터만 클라이언트에 제공 가능
  - 입력 데이터 검증 및 보안에 유리

#### - Lazy와 Eager
- JPA에서 연관된 엔티티를 로딩하는 전략은 크게 두 가지가 있음
  - 지연 로딩 : 실제로 해당 연관 객체가 호출될 때 쿼리를 실행
  - 즉시 로딩 : 연관 객체를 함께 즉시 로딩함
- Lazy (지연 로딩)
  - 연관된 객체를 사용할 때까지 로딩을 미룸
  - 초기 쿼리 성능 최적화 가능
  - N + 1 문제 발생 가능성 있음
- Eager(즉시 로딩)
  - 연관된 객체를 무조건 함께 로딩
  - 예기치 못한 쿼리 실행
  - 성능 저하 및 복잡한 객체 그래프 구성 시 부적합

#### - 다대일 연관관계 성능 최적화
- 대부분 연관 관계는 다대일 구조
- 기본 Fetch 전략으로 `@ManyToOne`, `@OneToOne`은 `EAGER`로 설정됨
- LAZY로 변경하고 필요 시 fetch join 사용

#### - N + 1 문제
1. Fetch Join
- Fetch Join은 연관된 엔티티를 SQL의 JOIN을 사용하여 한 번의 쿼리로 함꼐 조회하는 방법
- JPQL에서만 사용 가능하며 SQL에서의 JOIN과 유사하지만 의미상 차이 있음
- `JOIN FETCH` 키워드를 사용
- 연관된 엔티티를 즉시 로딩하며 Lazy 설정과 무관하게 작동
- 성능상 매우 유리하지만 잘못 사용 시 데이터 중복 페이징 불가 등의 문제가 발생할 수 있음
- 장점
  - N + 1 문제 해결
  - 객체 그래프를 효율적으로 초기화 가능
- 단점
  - 다대일은 문제 없지만 일대다에서는 데이터 중복 발생 가능성
  - 페이징 불가능
- 주의 사항
  - 다대다 또는 일대다 에서 Fetch Join을 사용할 경우 결과 집합이 커져 성능 저하 가능
  - 컬렉션 Fetch Join은 반드시 주의해서 사용
2. EntityGraph
- `@EntityGraph`는 JPA 2.1부터 도입된 기능으로 JPQL을 수정하지 않고도 연관 엔티티를 로딩하는 방법을 지정할 수 있음
- 선언형 방식으로 fetch join을 대체할 수 있으며, 재사용성과 유지보수 측면에서 매우 유리
- `@EntityGrapth(attributePaths = {...})` 형식으로 로딩할 연관 엔티티 지정
- JPA 구현체가 내부적으로 fetch join과 유사한 쿼리를 생성하여 로딩
- JPQL 재사용 가능
- 장점
  - 코드의 의도 명확성 증가
  - JPQL과 독립적으로 fetch 전략 지정 가능
  - 여러 EntityGraph 조합 가능
  - 조건문이 복잡한 JPQL을 깔끔하게 유지 가능
- 단점
  - 복잡한 조인이나 조건이 필요한 경우 JPQL fetch join만큼의 유연성은 부족
  - 연관 관계가 깊을 경우 attributePaths에 모든 경로를 명시해야 함
3. DTO 직접 조회
- DTO 직접 조회는 JPQL `new` 키워드를 사용하여 원하는 필드만 선택적으로 조회하고 그 결과를 DTO에 바로 매잎하는 방식
- 이 방식은 성능 최적화 관점에서 매우 유용하며 불필요한 필드 조회를 방지하고 N + 1 문제도 원천적으로 제거 가능
- 장점
  - 필요한 데이터 조회 : 엔티티 전체가 아닌 필요한 필드만 골라오기 때문에 네트워크와 DB 부하가 줄어듬
  - 엔티티가 아닌 순수 데이터 객체 반환 : JPA의 영속성 컨텍스트와 무관하게 관리되어 유지 보수성이 높음
  - N + 1 문제 방지 : 연관된 엔티티를 명시적으로 join으로 가져오므로 Lazy 로딩에 의한 추가 쿼리 발생이 없음
  - API 응답에 최적화된 구조 설계 가능 : 클라이언트 요구에 맞는 구조의 DTO를 생성 가능
- 단점
  - 쿼리 복잡도 증가 : DTO 생성자에 맞게 필드를 정확히 선택해야 하며 실수 시 런타임 오류 발생 가능
  - 쿼리 재사용성 낮음 : 특정 목적을 위해 작성된 쿼리이므로 범용성이 떨어질 수 있음
  - 유지보수 어려움 : 조회 항목이 바뀔 경우 쿼리와 DTO 모도 수정해야 함
4. 일대다 연관관계 성능 최적화
- 일대다 관계에서는 컬렉션 사용 시 데이터 증폭 문제 발생
- 페이징이 안 되는 문제가 가장 큰 단점
- 한 쿼리에서 JOIN FETCH로 OneToMany 컬렉션을 두 개 이상 조인하려고 하면 MultipleBagFetchException 같은 예외가 발생 가능

#### - 해결 방법
1. Fetch Join + DISTINCT
- JPA는 같은 Order 객체라도 OrderItem이 여러 개면 각각 결과에 포함
- `DISTINCT`를 사용하면 SQL과 JPA 레벨 양쪽에서 중복 제거

2. Fetch Join + Batch Size
- `@BatchSize` 또는 전역 설정으로 다건 조회 시 Lazy 로딩을 in 절로 해결
- 다대일, 일대다 관계 모두 적용 가능
- 페이징 사용 가능
- 장점
  - Fetch Join의 단점 해결
  - 쿼리 수 최적화
  - 성능과 유연성 규현 유지 가능
- 단점
  - 연관된 엔티티 수가 많은 경우 IN 절의 데이터가 많아져 오히려 성능 저하 발생 가능
  - 쿼리 수는 줄지만 가져오는 데이터 양이 많아 메모리 사용량이 증가할 수 있음
  - 적절한 Batch_size 설정을 휘안 캐싱 최적화 방식을 이해해야함

<!-- --- -->

<!-- <h2> 💬 </h2> -->

<!-- <h4>  </h4> -->
